#' Format Simulated Dataset for Hazard Ratio Calculation
#'
#' This internal function modifies the pooled-over-time dataset generated by the \code{\link{simulate}} function
#' to a format suitable for hazard ratio calculation.
#' @param i           Integer specifying the index \code{intcomp}.
#' @param intcomp     List of two numbers indicating the pair interventions to be used for the
#'                    hazard ratio calculation.
#' @param time_name   Character string specifying the name of the time variable in \code{pools}.
#' @param pools       Data table containing the simulated values for the covariates, outcome
#'                    probabilities, competing event probabilities, outcomes, and competing
#'                    events.
#' @return            Data table consisting of failure time information for each individual or the last time
#'                    point information (for individuals who do not experience an event).
#' @import data.table
hr_helper <- function(i, intcomp, time_name, pools){
  pool <- pools[[intcomp[[i]]]][, .SD, .SDcols = c("id", time_name, "Y", "D")]
  event_ids <- unique(pool[pool$Y == 1 | pool$D == 1]$id)
  # Take failure time for each ID
  new_pool <- pool[pool$Y == 1 | pool$D == 1][, .SD[1], id]
  # Bind to last time point of each ID for individuals who do not experience an event
  # Resulting datatable consists of information at censor time for each individual
  new_pool <- rbind(new_pool, pool[!id %in% event_ids][, .SD[.N], id])
  setorder(new_pool, id)

  # Encode no event, main event, and competing event as 0, 1, and 2, respectively
  # new_pool$event <- pmax(new_pool$Y, new_pool$D, na.rm = TRUE)
  set(new_pool, j = 'event', value = pmax(new_pool$Y, new_pool$D, na.rm = TRUE))
  # new_pool$Ycomp <- new_pool$event
  set(new_pool, j = 'Ycomp', value = new_pool$event)
  # new_pool[D == 1][event == 1]$Ycomp <- 2
  new_pool[new_pool$D == 1 & new_pool$event == 1, "Ycomp" := 2]

  # new_pool$regime <- i - 1
  set(new_pool, j = 'regime', value = i - 1)
  return (new_pool)
}

#' Error Catching
#'
#' This internal function catches potential errors in the user input in \code{\link{gformula_survival}}, \code{\link{gformula_continuous_eof}}, and \code{\link{gformula_binary_eof}}.
#'
#' @param id                     Character string specifying the name of the ID variable in \code{obs_data}.
#' @param nsimul                 Number of subjects for whom to simulate data.
#' @param intvars                Vector of character strings specifying the names of the variables to be intervened
#'                               on in each round of the simulation.
#' @param interventions          List of vectors. Each vector contains a function
#'                               implementing a particular intervention, optionally
#'                               followed by one or more "intervention values" (i.e.,
#'                               integers used to specify the treatment regime).
#' @param int_descript           Vector of character strings, each describing an intervention.
#' @param covnames               Vector of character strings specifying the names of the time-varying covariates in \code{obs_data}.
#' @param covtypes               Vector of character strings specifying the "type" of each time-varying covariate included in \code{covnames}. The possible "types" are: \code{"binary"}, \code{"normal"}, \code{"categorical"}, \code{"bounded normal"}, \code{"zero-inflated normal"}, \code{"truncated normal"}, and \code{"absorbing"}.
#' @param basecovs               Vector of character strings specifying the names of baseline covariates in \code{obs_data}.
#' @param histvars               Vector of character strings specifying the names of the variables for which history functions
#'                               are to be applied.
#' @param histories              Vector of history functions to apply to the variables specified in \code{histvars}.
#' @param compevent_model        Model statement for the competing event variable.
#' @param hazardratio            Logical scalar indicating whether the hazard ratio should be calculated
#'                               between two interventions.
#' @param intcomp                List of two numbers indicating the pair interventions to be used for the
#'                               hazard ratio calculation.
#' @param time_points            Number of time points to simulate.
#' @param time_name              Character string specifying the name of the time variable in \code{obs_data}.
#' @param outcome_type           Character string specifying the "type" of the outcome. The possible "types" are: \code{"survival"}, \code{"continuous_eof"}, and \code{"binary_eof"}.
#' @param obs_data               Data table containing the observed data.
#' @param parallel               Logical scalar indicating whether to parallelize simulations of
#'                               different interventions to multiple cores.
#' @param ncores                 Integer specifying the number of cores to use in parallel
#'                               simulation.
#' @param nsamples               Integer specifying the number of bootstrap samples to generate.
#' @param sim_data_b             Logical scalar indicating whether to return the simulated data set. If bootstrap samples are used (i.e., \code{nsamples} is set to a value greater than 0), this argument must be set to \code{FALSE}.
#'
#' @return                       No value is returned.
#' @import data.table
error_catch <- function(id, nsimul, intvars, interventions, int_descript,
                        covnames, covtypes, basecovs,
                        histvars, histories, compevent_model,
                        hazardratio, intcomp, time_points, outcome_type,
                        time_name, obs_data, parallel, ncores, nsamples,
                        sim_data_b){

  if (nsimul < length(unique(obs_data[[id]]))){
    warning("Number of simulated subjects desired is fewer than number of observed
            subjects")
  }

  if (outcome_type == 'survival' &&
      time_points > diff(range(obs_data[[time_name]]))+1){
    warning("Number of simulated time points desired is set to a value beyond the observed
            follow-up in the data")
  }

  if (!is.na(basecovs[[1]]) && time_points > diff(range(obs_data[[time_name]]))+1){
    warning("Baseline covariate values are being carried beyond the observed time range")
  }

  if (length(covnames) != length(covtypes)){
    stop("Missing covariate information (covnames and covtypes are of unequal length)")
  }

  for (k in 1:length(covnames)){
    if (covtypes[k] != 'categorical time' && covtypes[k] != 'categorical'){
      if (sum(obs_data[[covnames[k]]] < 0) != 0 && covtypes[k] == 'zero-inflated normal'){
        stop("zero-inflated normal covariates cannot contain negative values")
      }
    }
  }

  if (!is.na(ncores)){
    if (parallel && ncores > parallel::detectCores()){
      stop("Number of cores requested exceeds maximum available number")
    } else if (!parallel){
      stop("Multiple core use requested for non-parallelized function")
    }
  }

  if (grepl("eof", outcome_type) && time_points > diff(range(obs_data[[time_name]]))+1){
    stop("Number of simulated time points desired is set to a value beyond the observed
         follow-up in the data")
  }

  # Check that all intervention parameters are equal in length
  if ((is.na(intvars[[1]]) && !is.na(interventions)[[1]][[1]]) ||
      (!is.na(intvars[[1]]) && is.na(interventions)[[1]][[1]])){
    stop("Missing intervention information (intvars or interventions is NA)")
  }
  if (is.na(int_descript[[1]])){
    if (length(intvars) != length(interventions)){
      stop("Intervention parameters (intvars, interventions) are unequal lengths")
    }
  } else {
    if (!all(sapply(list(length(intvars), length(interventions)),
                    FUN = identical, length(int_descript)))){
      stop("Intervention parameters (intvars, interventions, int_descript) are unequal lengths")
    }
  }

  if (is.na(interventions)[[1]][[1]] && (hazardratio || !is.na(intcomp[[1]]))){
    stop("Cannot calculate hazard ratio if no interventions are specified")
  }

  # Ensure that if user desires to generate function(s) of history for certain
  # covariates, those covariates are named and the functions of history are specified
  if (is.na(histories[1]) && !is.na(histvars[1])){
    stop("Missing functions of history for covariates (histories)")
  }
  if (is.na(histories[1]) && is.na(histvars[1])){
    stop("Missing covariates for which to create histories (histvars)")
  }

  # Ensure that if the simulated data set is going to be returned, bootstrap
  # samples are not used
  if (nsamples > 0 & sim_data_b){
    stop("'sim_data_b' cannot be set to TRUE when nsamples > 0")
  }
}

trim_glm <- function(fit) {
  fit$y <- c()
  fit$model <- c()

  fit$residuals <- c()
  fit$fitted.values <- c()
  fit$effects <- c()
  fit$qr$qr <- c()
  fit$linear.predictors <- c()
  fit$weights <- c()
  fit$prior.weights <- c()
  fit$data <- c()

  fit$family$variance <- c()
  fit$family$dev.resids <- c()
  fit$family$aic <- c()
  fit$family$validmu <- c()
  fit$family$simulate <- c()
  attr(fit$terms,".Environment") <- c()
  attr(fit$formula,".Environment") <- c()

  return(fit)
}

trim_truncreg <- function(fit) {
  fit$gradientObs <- c()
  fit$fitted.values <- c()
  fit$y <- c()

  return(fit)
}

trim_multinom <- function(fit){
  fit$fitted.values <- c()
  fit$residuals <- c()
  fit$weights <- c()
  fit$y <- c()

  return(fit)
}

add_rmse <- function(fit){
  return (sqrt(mean((fit$y - stats::fitted(fit))^2)))
}

get_header <- function(int_descript, sample_size, nsimul, nsamples, ref_int){
  header <- paste0("PREDICTED RISK UNDER MULTIPLE INTERVENTIONS\n\n",
                   "Intervention \t Description\n",
                   "0 \t\t Natural course\n")
  if (!is.na(int_descript[1])){
    for (i in 1:length(int_descript)){
      header <- paste0(header, i, "\t\t ", int_descript[i], "\n")
    }
  } else {
    for (i in 1:length(int_descript)){
      header <- paste0(header, i, "\t\t None\n\n")
    }
  }
  header <- paste0(header, "\nSample size = ", sample_size,
                   ", Monte Carlo sample size = ", nsimul, "\n",
                   "Number of bootstrap samples = ", nsamples, "\n")
  if (ref_int == 0){
    header <- paste0(header, "Reference intervention = natural course (0)\n")
  } else {
    header <- paste0(header, "Reference intervention = ", ref_int, "\n\n")
  }
}

clusterAssign <- function(cl, name, value) {
  parallel::clusterCall(cl, assign, x = name, value = value, envir = .GlobalEnv)
}
